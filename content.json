{"meta":{"title":"JKXY Blog","subtitle":"茫茫人海中的一名程序员","description":"JKXY的个人博客","author":"JKXY","url":"http://jkxy.club"},"pages":[{"title":"404","date":"2017-11-30T02:06:25.190Z","updated":"2017-11-30T02:06:03.469Z","comments":true,"path":"404.html","permalink":"http://jkxy.club/404.html","excerpt":"","text":"404"},{"title":"","date":"2017-11-30T01:44:27.888Z","updated":"2017-11-30T01:44:27.888Z","comments":true,"path":"404css/error.css","permalink":"http://jkxy.club/404css/error.css","excerpt":"","text":"body, div { margin: 0; padding: 0; } body { background: url(\"../images/error_bg.jpg\") repeat-x scroll 0 0 #67ACE4; } #container { margin: 0 auto; padding-top: 50px; text-align: center; width: 560px; } #container img { border: medium none; margin-bottom: 50px; } #container .error { height: 200px; position: relative; } #container .error img { bottom: -50px; position: absolute; right: -50px; } #container .msg { margin-bottom: 65px; } #cloud { background: url(\"../images/error_cloud.png\") repeat-x scroll 0 0 transparent; bottom: 0; height: 170px; position: absolute; width: 100%; }"},{"title":"","date":"2017-08-14T08:13:10.324Z","updated":"2017-05-19T08:59:29.268Z","comments":false,"path":"categories/index.html","permalink":"http://jkxy.club/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-14T08:13:10.339Z","updated":"2017-05-19T08:59:10.686Z","comments":false,"path":"tags/index.html","permalink":"http://jkxy.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"android gradle 3.0.0 中依赖指令implementation、api 的区别","slug":"android gradle 3.0.0 中依赖指令implementation、api 的区别","date":"2018-04-03T03:21:07.000Z","updated":"2018-04-03T03:25:09.093Z","comments":true,"path":"post/f00095c8.html","link":"","permalink":"http://jkxy.club/post/f00095c8.html","excerpt":"","text":"转载：https://blog.csdn.net/Next_Second/article/details/78428086 AndroidStudio升级到3.0之后，gradle版本也随之升级到了3.0.0版本。 classpath &apos;com.android.tools.build:gradle:3.0.0&apos; 在新建一个Android工程的时候，build.gradle中的依赖默认为implementation，而不是之前的compile。另外，gradle 3.0.0版本以上，还有依赖指令api。本文主要介绍下implementation和api的区别。 新建工程默认生成的app的build.gradle文件中的依赖： dependencies { implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos; } api 指令完全等同于compile指令，没区别，你将所有的compile改成api，完全没有错。 implementation指令这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。 简单的说，就是使用implementation指令的依赖不会传递。例如，有一个module为testsdk，testsdk依赖于gson： implementation &apos;com.google.code.gson:gson:2.8.2&apos; 这时候，在testsdk里边的java代码是可以访问gson的。 另一个module为app，app依赖于testsdk： implementation project(&apos;:testsdk&apos;) 这时候，因为testsdk使用的是implementation 指令来依赖gson，所以app里边不能引用gson。 但是，如果testsdk使用的是api来引用gson： api &apos;com.google.code.gson:gson:2.8.2&apos; 则与gradle3.0.0之前的compile指令的效果完全一样，app的module也可以引用gson。这就是api和implementation的区别。 建议在Google IO 相关话题的中提到了一个建议，就是依赖首先应该设置为implementation的，如果没有错，那就用implementation，如果有错，那么使用api指令。使用implementation会使编译速度有所增快。 provided（compileOnly）只在编译时有效，不会参与打包可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 其它apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。 testCompile（testImplementation）testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。 debugCompile（debugImplementation）debugCompile 只在 debug 模式的编译和最终的 debug apk 打包时有效 releaseCompile（releaseImplementation）Release compile仅仅针对 Release 模式的编译和最终的 Release apk 打包。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"软件开发模式对比(瀑布、迭代、螺旋、敏捷)","slug":"软件开发模式对比","date":"2017-12-05T02:51:21.000Z","updated":"2017-12-05T03:02:04.005Z","comments":true,"path":"post/5acbcc97.html","link":"","permalink":"http://jkxy.club/post/5acbcc97.html","excerpt":"","text":"来源：https://www.cnblogs.com/tianguook/p/4004726.html http://www.mamicode.com/info-detail-556125.html 瀑布模型瀑布模型是由W.W.Royce在1970年最初提出的软件开发模型，瀑布式开发是一种老旧的计算机软件开发方法。瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。 瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 瀑布模型的特点（传统的开发方式）： 强调文档，前一个阶段的输出就是下一个阶段的输入，文档是个阶段衔接的唯一信息。所以很多开发人员好象是在开发文档，而不是开发软件，因为要到开发的后期才可以看到软件的“模样”。 没有迭代与反馈。瀑布模型对反馈没有涉及，所以对变化的客户需求非常不容易适应。瀑布就意味着没有回头路。 管理人员喜欢瀑布模型的原因是把文档理解为开发的速度，可以方便地界定不同阶段的里程碑。 迭代式开发迭代式开发也被称作迭代增量式开发或迭代进化式开发，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。 什么是迭代式开发？ 每次只设计和实现这个产品的一部分, 逐步逐步完成的方法叫迭代开发, 每次设计和实现一个阶段叫做一个迭代. 在迭代式开发方法中，整个开发工作被组织为一系列的短小的、 固定长度（如3周）的小项目，被称为一系列的迭代。 每一次迭代都包括了需求分析、设计、实现与测试。 采用这种方法，开发工作可以在需求被完整地确定之前启动， 并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。 再通过客户的反馈来细化需求，并开始新一轮的迭代。 迭代式开发的优点： 降低风险 得到早期用户反馈 持续的测试和集成 使用变更 提高复用性 螺旋开发螺旋开发，1988年，巴利·玻姆(Barry Boehm)正式发表了软件系统开发的“螺旋模型”，它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。“螺旋模型”刚开始规模很小，当项目被定义得更好、更稳定时，逐渐展开。 “螺旋模型”的核心就在于您不需要在刚开始的时候就把所有事情都定义的清清楚楚。您轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。如此不断轮回重复，直到得到您满意的最终产品。 （1）制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件； （2）风险分析：分析评估所选方案，考虑如何识别和消除风险； （3）实施工程：实施软件开发和验证； （4）客户评估：评价开发工作，提出修正建议，制定下一步计划。 螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。 敏捷软件开发敏捷软件开发又称敏捷开发， 是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不 尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织 型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。 人和交互 重于过程和工具。 可以工作的软件 重于求全而完备的文档。 客户协作 重于合同谈判。 随时应对变化 重于循规蹈矩。 其中位于右边的内容虽然也有其价值，但是左边的内容最为重要。人员彼此信任 人少但是精干 可以面对面的沟通 项目的敏捷开发：敏捷开发小组主要的工作方式可以归纳为：作为一个整体工作； 按短迭代周期工作； 每次迭代交付一些成果； 关注业务优先级； 检查与调整。 最重要的因素恐怕是项目的规模。规模增长，面对面的沟通就愈加困难，因此敏捷方法更适用于较小的队伍，40、30、20、10人或者更少。大规模的敏捷软件开发尚处于积极研究的领域。 敏捷开发集成了新型开发模式的共同特点，它重点强调： 敏捷就是“快”。快才可以适应目前社会的快节奏，要快就要发挥个人的个性思维多一些个性思维的增多。 客户参与。以人为本，客户是软件的使用者，是业务理解的专家，没有客户的参与，开发者很难理解客户的真实需求。 强调软件开发的产品是软件，而不是文档。文档是为软件开发服务的，而不是开发的主体。 设计周密是为了最终软件的质量，但不表明设计比实现更重要。 迭代。软件的功能是客户的需求，界面的操作是客户的“感觉”。对迭代的强调是缩短了软件版本的周期。 小版本。快速功能的展现，看似简单，但对于复杂的客户需求合理地分割与总体上的统一，要很好地二者兼顾是不容易的。 四者对比区别 传统的瀑布式开发，也就是从需求到设计，从设计到编码，从编码到测试，从测试到提交大概这样的流程，要求每一个开发阶段都要做到最好。特别是前期阶段，设计的越完美，提交后的成本损失就越少。 迭代式开发，不要求每一个阶段的任务做的都是最完美的，而是明明知道还有很多不足的地方，却偏偏不去完善它，而是把主要功能先搭建起来为目的，以最短的时间， 最少的损失先完成一个“不完美的成果物”直至提交。然后再通过客户或用户的反馈信息，在这个“不完美的成果物”上逐步进行完善。 螺旋开发，很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。 敏捷开发，相比迭代式开发两者都强调在较短的开发周期提交软件，但是，敏捷开发的周期可能更短，并且更加强调队伍中的高度协作。敏捷方法有时候被误认为是无计划性和纪律性的方法，实际上更确切的说法是敏捷方法强调适应性而非预见性。 适应性的方法集中在快速适应现实的变化。当项目的需求起了变化，团队应该迅速适应。这个团队可能很难确切描述未来将会如何变化.","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://jkxy.club/tags/其它/"}]},{"title":"Android 广告跳过","slug":"Android广告跳过","date":"2017-11-18T05:52:06.000Z","updated":"2017-11-30T03:25:30.618Z","comments":true,"path":"post/8d1f962d.html","link":"","permalink":"http://jkxy.club/post/8d1f962d.html","excerpt":"","text":"前言前段时间，去了一趟杭州找我朋友玩，出去在公交车上的时候，我也是和平常一样，拿出了手机，想刷一会知乎，但是当我打开知乎，出来的却是烦人的广告，这个广告“很贴心”的给了我们一个“跳过”按钮，让我们可以不要等待那么长的广告时间，于是我就去点击了那个按钮，但是，你们知道我这时正在公交车上呢，结果悲剧就来了，我居然点偏了，直接就进入了广告。发生这一幕，作为一个程序猿，这不能忍啊。 思路于是我就在想怎么解决这个问题，回忆了一下其它针对广告的方案，发现大部分都是通过反编译实现的，但是这太复杂麻烦了，而且APP不能更新，更新了又要重新处理，感觉不是我理想的方式，于是又在想有没有其它的方案，这时我灵光一闪，他不是提供了“跳过”的按钮给我吗，我们自己去点击又累又烦，而且有时候会点偏，我可以做一个APP，让这个APP帮助我们去点这个按钮啊，岂不美哉！接下来，就要考虑要怎么实现了，我们来分析一下，有那些难点： 怎么判断是在广告页面； 怎么实现自动点击跳过按钮； 分析到这两个问题，我立马就想到了Android手机的无障碍服务AccessibilityService，他完全可以处理两个问题啊，于是立马就开干。 成果在实现过程中，我发现实现起来比我想的麻烦的多，因为我们要去判断每个APP的广告页，而每个APP的跳过按钮又不一样，要想实现不同的APP跳过方案，就必须去一个一个的适配，这个过程其实是非常烦躁的，但一想到这是一劳永逸的事情，就又充满了干劲，在我的不懈努力下，目前适配了如下APP： 知乎、智行火车票、一点资讯小米版、网易云音乐、斗鱼直播、熊猫直播、网易新闻、今日头条、腾讯视频、中国移动、中国联通、招商银行、中国建设银行、掌上生活、携程旅行、ofo共享单车、摩拜单车、内涵段子、搜狐视频、酷狗音乐、全民K歌、QQ空间、土豆视频、AcFun、百度网盘、火萤、安兔兔测评、百度浏览器、掌阅、起点读书、QQ阅读、懒人听书、喜马拉雅FM、追书神器、宜搜小说、知音漫客、腾讯动漫、美柚、饿了么、百度外卖、义乌购、当当、苏宁易购、闲鱼、WIFI万能钥匙、迅雷、豆瓣、京东金融、虾米音乐、一淘、美图秀秀、驾考宝典、米家有品、唯品会、唱吧、雪球股票、爱奇艺、花生地铁WIFI APK下载：点我","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Android APK反编译、重新打包","slug":"Android APK反编译、重新打包","date":"2017-09-15T09:06:17.000Z","updated":"2017-11-30T03:25:30.587Z","comments":true,"path":"post/fe82999d.html","link":"","permalink":"http://jkxy.club/post/fe82999d.html","excerpt":"","text":"工具介绍工具下载 baksmali： 把classes.dex转为为smali文件的工具 dex2jar： classes.dex转为jar包的工具 jdgui： 阅读jar文件的工具（分linux和windows版本，资源中一并给出） smali： 把smali文件编译打包为classes.dex的工具 其中关于baksmali和smali可以看下谷歌的介绍:http://baksmali.com dex2jar和jdgui不是必须的，只是用来查看源码的，因为直接看smali文件难度较大 破解步骤1.解压apk文件，获取classes.dex并拷贝到资源根目录（使用zip或其他解压工具即可） 2.使用baksmali工具将classes.dex转为smali文件，在命令行定位到资源根目录并执行： java -jar baksmali-2.0.3.jar -x classes.dex 执行完后会在当前目录下生成out目录，目录结构跟源码相同，在对应目录下查找对应的smali文件 3.使用dex2jar工具把dex转为jar文件，拷贝classes.dex到资源目录下的dex2jar-0.0.9.15目录下，把命令行定位到该目录并执行： ./dex2jar.sh classes.dex (windows:dex2jar.bat classes.dex) 执行完后会在当前目录下生成classes_dex2jar.jar文件，然后可以通过jdgui进行查看 4.使用jdgui工具查看APK的源码，根据不同的系统打开资源目录下对应的jdgui工具，然后把第3步生成的classes_dex2jar.jar文件拖到工具中 5.修改对应的smali文件 6.使用smali-2.0.3.jar工具把smali文件转为dex文件，把命令行定位到资源根目录并执行： java -jar smali-2.0.3.jar -o classes.dex out 执行完后会生成并替换掉根目录下的classes.dex文件，这样就修改成功了 7.把新生成的classes.dex文件替换到原来的apk文件里（使用压缩工具） 8.使用签名工具对apk进行签名，把apk拷贝到资源根目录下的sign_tool目录，把命令行定位到该目录并执行： java -jar signapk.jar platform.x509.pem platform.pk8 test.apk changetest.apk 执行完后会在该目录下生成changetest.apk文件，这个文件就是最终的文件了 9.卸载原来的APK，安装第8步中生成的changetest.apk文件 参考：http://blog.csdn.net/lucherr/article/details/39896549","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Monkey的使用","slug":"Monkey的使用","date":"2017-09-04T03:41:58.000Z","updated":"2017-11-30T03:25:30.667Z","comments":true,"path":"post/6035586f.html","link":"","permalink":"http://jkxy.club/post/6035586f.html","excerpt":"","text":"基本介绍Monkey就是猴子， Monkey测试，就像一只猴子， 在电脑面前，乱敲键盘在测试。 猴子什么都不懂， 只知道乱敲通过Monkey程序模拟用户触摸屏幕、滑动Trackball、 按键等操作来对设备上的程序进行压力测试，检测程序多久的时间会发生异常。 Monkey是一个命令行工具，可以运行在模拟器里或实际设备中，使用安卓调试桥(adb)来运行它，向系统发送伪随机的用户事件流，实现对正在开发的应用程序进行压力测试，可以根据获取的log信息进行修复。 Monkey程序由Android系统自带，使用Java语言写成，在Android文件系统中的存放路径是： /system/framework/monkey.jar； Monkey.jar程序是由一个名为“monkey”的Shell脚本来启动执行，shell脚本在Android文件系统中 的存放路径是：/system/bin/monkey； Monkey 命令启动方式： 可以通过PC机CMD窗口中执行: adb shell monkey ｛+命令参数｝来进行Monkey测试 在PC上adb shell 进入Android系统，通过执行 monkey {+命令参数} 来进行Monkey 测试 在Android机或者模拟器上直接执行monkey 命令，可以在Android机上安装Android终端模拟器 基本命令`-help` 列出简单用法 `-v` 作用： 命令行上的每一个-v都将增加反馈信息的详细级别。 Level1（默认），除了启动、测试完成和最终结果外只提供较少的信息。 Level2，提供了较为详细的测试信息，如逐个发送到Activity的事件信息。 Level3，提供了更多的设置信息，如测试中选中或未选中的Activity信息。 例： adb shell monkey -v 10 adb shell monkey -v -v 10 adb shell monkey -v -v -v 10 `-s` &lt;seed&gt; 作用：伪随机数生成器的seed值。如果用相同的seed值再次运行monkey，将生成相同的事件序列。 例： adb shell monkey -s 12345 -v 10 --throttle &lt;milliseconds&gt; 作用：在事件之间插入固定的时间（毫秒）延迟，你可以使用这个设置来减缓Monkey的运行速度，如果你不指定这个参数，则事件之间将没有延迟，事件将以最快的速度生成。 例： adb shell monkey –throttle 300 -v 10 注：常用参数，一般设置为300毫秒，原因是实际用户操作的最快300毫秒左右一个动作事件，所以此处一般设置为300毫秒。 -p &lt;allowed-package-name&gt; 作用：如果你指定一个或多个包，Monkey将只允许访问这些包中的Activity。如果你的应用程序需要访问这些包(如选择联系人)以外的Activity，你需要指定这些包。如果你不指定任何包，Monkey将允许系统启动所有包的Activity。指定多个包，使用多个-p，一个-p后面接一个包名。 例： adb shell monkey -p com.android.browser -v 10 -c &lt;main-category&gt; 作用：如果你指定一个或多个类别，Monkey将只允许系统启动这些指定类别中列出的Activity。如果你不指定任何类别，Monkey将选择谢列类别中列出的Activity，Intent.CATEGORY_LAUNCHER和Intent.CATEGORY_MONKEY。指定多个类别使用多个-c，每个-c指定一个类别。 例： adb shell monkey -p com.paipai.ershou -v 10 -c --pct-touch &lt;percent&gt; 作用：调整触摸事件的百分比。（触摸事件是指在屏幕中的一个down-up事件，即在屏幕某处按下并抬起的操作） 例： adb shell monkey –pct-touch 100 -v 10 注：常用参数，此参数设置要适应当前被测应用程序的操作，比如一个应用80%的操作都是触摸，那就可以将此参数的百分比设置成相应较高的百分比。 --pct-motion &lt;percent&gt; 作用：调整motion事件百分比。（motion事件是由屏幕上某处一个down事件、一系列伪随机的移动事件和一个up事件组成） 例： adb shell monkey –pct-motion 100 -v 10 注：常用参数，需注意的是移动事件是直线滑动，下面的trackball移动包含曲线移动。 --ignore-crashes 作用：通常，应用发生崩溃或异常时Monkey会停止运行。如果设置此项，Monkey将继续发送事件给系统，直到事件计数完成。 --ignore-timeouts 作用：事件请求超时会影响monkey的测试。如果设置此项，Monkey将继续发送事件给系统，直到事件计数完成。 保存测试日志 adb shell monkey -p com.ihongqiqu -v -v -v 500 &gt; test.txt 参考：https://developer.android.com/studio/test/monkey.html","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"仿探探小Demo","slug":"仿探探小Demo","date":"2017-08-03T08:26:40.000Z","updated":"2017-11-30T03:25:30.673Z","comments":true,"path":"post/29b4468.html","link":"","permalink":"http://jkxy.club/post/29b4468.html","excerpt":"","text":"为了学习DataBinding，自己模仿了探探写的一个小Demo。 里面主要关键点有：DataBinding的使用，人脸检测，仿探探雷达扫描附近的人效果，仿探探卡片滑动效果，转场动画等 Github地址：https://github.com/JKXY/tantandemo","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"关于CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout","slug":"关于CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout","date":"2017-07-19T13:08:11.000Z","updated":"2017-11-30T03:25:30.634Z","comments":true,"path":"post/b3792a9c.html","link":"","permalink":"http://jkxy.club/post/b3792a9c.html","excerpt":"","text":"CoordinatorLayoutpublic class CoordinatorLayout extends ViewGroup implements NestedScrollingParent CoordinatorLayout使用新的思路通过协调调度子布局的形式实现触摸影响布局的形式产生动画效果。CoordinatorLayout通过设置子View的 Behaviors来调度子View。系统（Support V7）提供了AppBarLayout.Behavior, AppBarLayout.ScrollingViewBehavior, FloatingActionButton.Behavior, SwipeDismissBehavior 等。 AppBarLayoutpublic class AppBarLayout extends LinearLayout AppBarLayout是一个垂直的LinearLayout，实现了Material Design中app bar的scrolling gestures特性。 AppBarLayout的子View应该声明想要具有的“滚动行为”，这可以通过layout_scrollFlags属性或是setScrollFlags()方法来指定。 AppBarLayout只有作为CoordinatorLayout的直接子View时才能正常工作，为了让AppBarLayout能够知道何时滚动其子View，我们还应该在CoordinatorLayout布局中提供一个可滚动View，我们称之为scrolling view。 scrolling view和AppBarLayout之间的关联，通过将scrolling view的Behavior设为AppBarLayout.ScrollingViewBehavior来建立。 ScrollFlags共有五种常量值供AppBarLayout的Children View使用，在xml布局文件中通过app:layout_scrollFlags设置，对应的值为：scroll，enterAlways，enterAlwaysCollapsed，snap，exitUntilCollapsed；也可以在代码中通过setScrollFlags(int)方法使用 介绍1.scroll:值设为scroll的View会跟随滚动事件一起发生移动；所有想滚动出屏幕的view都需要设置这个flag，没有设置这个flag的view将被固定在屏幕顶部。 2.enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动，而不用考虑ScrollView是否在滚动；这个flag让任意向下的滚动都会导致该view变为可见，如启用快速“返回模式”。 3.exitUntilCollapsed:值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。 4.enterAlwaysCollapsed:是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时(注意你的view需要设置minHeight属性)，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。 5.snap:在一次滚动结束时，本View很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。 几种情况1.scroll：上滑动时，toolbar隐藏；下滑时先滑动scrollview类似的view，待滚动至顶部时，再滑动toolbar至可见 2.scroll|enterAlways：上滑动时，toolbar隐藏；下滑时先滑动toolbar至可见，再滑动scrolling view 3.scroll|enterAlways|enterAlwaysCollapsed: 需要设置 android:layout_height=&quot;@dimen/dp_200&quot; android:minHeight=&quot;@dimen/dp_56&quot; 上滑动时，toolbar隐藏；下滑时先滑动toolbar显示minHeight高度，接着滑动滚动布局显示顶部内容，最后再次滑动toolbar至height设置的高度，并显示标题 4.scroll|exitUntilCollapsed 需要设置 android:layout_height=&quot;@dimen/dp_200&quot; android:minHeight=&quot;@dimen/dp_56&quot; 上滑动时，toolbar收缩至minheight,但不隐藏；下滑时先滑动滚动布局显示顶部内容，接着滑动toolbar至height设置的高度，并显示标题（与3不同的是toolbar不会完全消失） 注意：写了app:layout_scrollFlags属性的话布局会下移，假如有固定在底部的view可能会被挤出屏幕外。 CollapsingToolbarLayoutpublic class CoordinatorLayout extends ViewGroup implements NestedScrollingParent CollapsingToolbarLayout通常用来在布局中包裹一个Toolbar，以实现具有“折叠效果“”的顶部栏。它需要是AppBarLayout的直接子View，这样才能发挥出效果。CollapsingToolbarLayout包含以下特性： Collasping title（可折叠标题）：当布局完全可见时，这个标题比较大；当折叠起来时，标题也会变小。标题的外观可以通过expandedTextAppearance和collapsedTextAppearance属性来调整。 Content scrim（内容纱布）：根据CollapsingToolbarLayout是否滚动到一个临界点，内容纱布会显示或隐藏。可以通过setContentScrim(Drawable)来设置内容纱布。 Status bar scrim（状态栏纱布）：也是根据是否滚动到临界点，来决定是否显示。可以通过setStatusBarScrim(Drawable)方法来设置。这个特性只有在Android5.0及其以上版本，我们设置fitSystemWindows为ture时才能生效。 Parallax scrolling children（视差滚动子View）：子View可以选择以“视差”的方式来进行滚动。（视觉效果上就是子View滚动的比其他View稍微慢些） Pinned position children：子View可以选择固定在某一位置上。 注意 AppBarLayout必须是CoordinatorLayout的直接子View 只要CollapsingToolbarLayout里面包含有toolbar那么CollapsingToolbarLayout的折叠后高度就是toolbar的高度,相当于CollapsingToolbarLayout设置了minHeight属性. CollapsingToolbarLayout折叠到最顶端时,它就是老大,会处于最上层,包括toolbar在内,所有的布局都会被他盖住,显示不出来. 怎么实现固定表头,这个也简单,写一个布局放在CollapsingToolbarLayout之后,AppBarLayout之内即可,xml文件中自己找找看吧.你要是问如果放在CollapsingToolbarLayout之前,AppBarLayout之内会怎么样?这样折叠布局就不起作用了.不会折叠了.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Android中常用的特殊字符","slug":"Android中常用的特殊字符","date":"2017-06-27T08:58:56.000Z","updated":"2017-11-30T03:25:30.587Z","comments":true,"path":"post/4d3be038.html","link":"","permalink":"http://jkxy.club/post/4d3be038.html","excerpt":"","text":"字符 十进制 转义字符 &quot; &amp;#34; &amp;quot; &#39; &amp;#39; &amp;apos; &amp; &amp;#38; &amp;amp; lt(&lt;) &amp;#60; &amp;lt; gt(&gt;) &amp;#62; &amp;gt; 不断开空格 &amp;#160； &amp;nbsp; 版权符&copy; &amp;#169; &amp;copy; 注册符&reg; &amp;#174; &amp;reg; 空格 &amp;#x0020; Tab &amp;#x0009; 回车 &amp;#x000D; 换行 &amp;#x000A; 特殊字符大全：http://www.jb51.net/onlineread/htmlchar.htm","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Fresco中SimpleDraweeView的XML属性说明","slug":"Fresco中SimpleDraweeView的XML属性说明","date":"2017-06-26T08:00:30.000Z","updated":"2017-11-30T03:25:30.634Z","comments":true,"path":"post/e3fd73ec.html","link":"","permalink":"http://jkxy.club/post/e3fd73ec.html","excerpt":"","text":"属性 说明 fadeDuration 淡入淡出动画持续时间(单位：毫秒ms) actualImageScaleType 实际图像的缩放类型 placeholderImage 占位图 placeholderImageScaleType 占位图的缩放类型 progressBarImage 进度图 progressBarImageScaleType 进度图的缩放类型 progressBarAutoRotateInterval 进度图自动旋转间隔时间(单位：毫秒ms) failureImage 失败图 failureImageScaleType 失败图的缩放类型 retryImage 重试图 retryImageScaleType 重试图的缩放类型 backgroundImage 背景图 overlayImage 叠加图 pressedStateOverlayImage 按压状态下所显示的叠加图 roundAsCircle 设置为圆形图 roundedCornerRadius 圆角半径 roundTopLeft 左上角是否为圆角 roundTopRight 右上角是否为圆角 roundBottomLeft 左下角是否为圆角 roundBottomRight 右下角是否为圆角 roundingBorderWidth 圆形或者圆角图边框的宽度 roundingBorderColor 圆形或者圆角图边框的颜色 roundWithOverlayColor 圆形或者圆角图底下的叠加颜色(只能设置颜色) viewAspectRatio 控件纵横比","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Android通过外网IP获取定位信息的几种方式","slug":"Android通过外网IP获取定位信息的几种方式","date":"2017-06-16T03:35:32.000Z","updated":"2017-11-30T03:25:30.618Z","comments":true,"path":"post/532ab633.html","link":"","permalink":"http://jkxy.club/post/532ab633.html","excerpt":"","text":"方法一 通过聚合数据的IP定位API 进行城市定位 (无需SDK，需传入外网IP)可通过聚合数据的API实现 方法二 通过百度地图API进行定位 (无需SDK，可选择传入外网IP)百度地图 普通IP定位API 方法三 通过百度地图SDK进行定位 (需要SDK，无需传入外网IP)百度地图Android定位SDK 方法四 通过高德地图开放平台进行定位 (需要SDK，无需传入外网IP)高德地图Android定位SDK 参考：http://blog.csdn.net/ethanco/article/details/52777032","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"记RecyclerView的notifyItemRemoved方法的坑","slug":"记RecyclerView的notifyItemRemoved方法的坑","date":"2017-06-08T04:34:41.000Z","updated":"2017-11-30T03:25:30.678Z","comments":true,"path":"post/988003c4.html","link":"","permalink":"http://jkxy.club/post/988003c4.html","excerpt":"","text":"在我们使用 RecyclerView 时需要删除一条数据时，RecyclerView 很是友好的给我们提供了 notifyItemRemoved 方法，且带有动画效果，但是当使用完之后你就会发现前方有一个坑在等着你。 具体情况当我们使用 notifyItemRemoved 方法后，该方法不会使 position 及其之后位置的 vitemiew 重新 onBindViewHolder。所以会导致下标错乱，然后各种坑爹的bug就来了。 就像这样： 现在有1，2，3，4个数据. 你第一次删，比如删掉2，这次删除结果是对的，位置2的view消失，数据里原有的第2项也被删除。 接下来你再删除现在的第2项（原来的第三项）时，调试你会发现，由于绑定时 contentList.remove(position); notifyItemRemoved(position); 这里记住的postion是3，那么这次被删除的数据项会是现有的数据列表的第三项（应该是第二项的）。 解决方法public void remove(int position) { mDataList.remove(position); notifyItemRemoved(position); if(position != mDataList.size()){ // 如果移除的是最后一个，忽略 notifyItemRangeChanged(position, mDataList.size() - position); } } remove：把数据从 list 中 remove 掉 notifyItemRemoved：列表删除 View 且显示动画效果 notifyItemRangeChanged：对于被删掉的位置及其后 range 大小范围内的 view 进行重新 onBindViewHolder 参考： http://blog.csdn.net/wangkai0681080/article/details/50082825 http://www.2cto.com/kf/201608/534945.html","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Android透明度对比图","slug":"Android透明度对比图","date":"2017-05-25T02:09:33.000Z","updated":"2017-11-30T03:25:30.618Z","comments":true,"path":"post/e0213c9c.html","link":"","permalink":"http://jkxy.club/post/e0213c9c.html","excerpt":"","text":"透明度 数值 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00 说明 透明度分为256阶（0-255） 50%即255*50% Android xml里面是用十六进制表示：Integer.toHexString( 255*50% ).toUpperCase();-&gt;80","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Android通过WIFI连接真机调试","slug":"Android通过WIFI连接真机调试","date":"2017-05-25T01:37:51.000Z","updated":"2017-11-30T03:25:30.602Z","comments":true,"path":"post/f356c74.html","link":"","permalink":"http://jkxy.club/post/f356c74.html","excerpt":"","text":"前言在实际开发中，我们进行真机调试一般都是通过USB数据线进行连接，然而这种方式有很多不便之处，比如：连接经常断开，对充电口伤害大等等。如果有一种方式能够使我们不用USB数据线就好了，本篇文章就来告诉你如何通过WIFI连接进行真机调试。 前提条件 手机和电脑必须在同一局域网内 配置好adb环境变量 手机和电脑通过USB数据线进行adb连接正常，不要让其他程序占用adb 执行命令 命令 说明 adb tcpip 5555 修改adb连接方式为WIFI连接（PS：这一步需要通过USB数据线和电脑正常连接，这步只需执行一次，下次不需要执行了） adb connect 192.168.1.106 通过WIFI连接手机（PS：192.168.1.106为你手机WIFI连接的IP地址） 好了，到此为止，你就是能够解开USB数据线的困扰了，通过WIFI爽快的调试了！ 其他如果你那天不想用WIFI的方式了，你可以用以下的命令修改回USB连接： adb usb 参考：http://www.jianshu.com/p/3c1b97330150# 相关资料ADB详细介绍：https://developer.android.com/studio/command-line/adb.html","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"}]},{"title":"Android设计模式之单例模式","slug":"Android设计模式之单例模式","date":"2017-05-22T08:22:39.000Z","updated":"2017-11-30T03:25:30.602Z","comments":true,"path":"post/115198f6.html","link":"","permalink":"http://jkxy.club/post/115198f6.html","excerpt":"","text":"参考：https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/tree/master/singleton/mr.simple 模式的定义确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 模式的使用场景确保某个类有且只有一个对象的场景，例如创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源。 UML类图 实现介绍单例模式是设计模式中最简单的，只有一个单例类，没有其他的层次结构与抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗太多的资源或者没有没有多个实例的理由。 方式一：public class Singleton{ private static final Singleton mSingleton = new Singleton (); public static Singleton getSingleton() { return mSingleton; } } 方式二：/** *double-check， 避免并发时创建了多个实例, 该方式不能完全避免并发带来的破坏. */ public class Singleton { private static Sinleton mInstance = null; public static Singleton getInstance(){ if(mInstance == null){ synchronized (Sinleton.class){ mInstance = new Singleton(); } } return mInstance; } } 方式三：public class Singleton { /** * 静态内部类 * * @author mrsimple * */ private static class SingletonHolder { private static final Singleton mOnlyInstance = new Singleton(); } /** * 在第一次加载SingletonHolder时初始化一次mOnlyInstance对象, 保证唯一性, 也延迟了单例的实例化, * 如果该单例比较耗资源可以使用这种模式. * * @return */ public static Singleton getInstanceFromHolder() { return SingletonHolder.mOnlyInstance; } } 方式四：/** * 方式四 : 枚举单例, 线程安全 */ public class Singleton { enum SingletonEnum{ INSTANCE; } } 方式五 :public class Singleton { /** * 方式五 : 注册到容器, 根据key获取对象.一般都会有多种相同属性类型的对象会注册到一个map中 * instance容器 */ private static Map&lt;string singleton=&quot;&quot;&gt; objMap = new HashMap&lt;string singleton=&quot;&quot;&gt;(); /** * 注册对象到map中 * @param key * @param instance */ public static void registerService(String key, Singleton instance) { if (!objMap.containsKey(key) ) { objMap.put(key, instance) ; } } /** * 根据key获取对象 * @param key * @return */ public static Singleton getService(String key) { return objMap.get(key) ; } } 不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。 优点由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决；单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。 缺点单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://jkxy.club/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jkxy.club/tags/设计模式/"}]},{"title":"诞生日记","slug":"诞生日记","date":"2017-05-22T03:56:33.000Z","updated":"2017-11-30T03:25:30.683Z","comments":true,"path":"post/e12c5c0a.html","link":"","permalink":"http://jkxy.club/post/e12c5c0a.html","excerpt":"","text":"作为一个小白，只会Android，其他都是不怎么了解，Hexo之前从来都没有听说过，git因为工作原因也没有使用（一直在SVN的世界），github也因为自己矬B的英语，用的也很少，不过即使是这样，也一直想搭建一个自己的博客，一个程序员的家。可是一直都是无从下手的感觉，突然有一天，看到一篇文章说是使用github+hexo能快速的搭建自己的个人博客，然后就看了一下，发现确实很简单（还是太年轻，过程中遇到了很多坑啊），自己又google了一下，看了其他相关的文章，确实很不错，于是就开启自己个人博客搭建之旅了。 一、了解Hexo你要了解一样东西，最好的方式就是看官方文档传送门。下面简单记录一下有关Hexo的东西。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提检查电脑中是否已安装下列应用程序： Node.js Git 安装（使用命令）：$ npm install -g hexo-cli 常用命令 名字 命令 说明 新建网站 $ hexo init [folder] folder 为存放目录 新建文章 $ hexo new [layout] layout 布局， 生成静态文件 $ hexo g 这是简写generate 启动服务器 $ hexo s server，访问网址为： http://localhost:4000/ 部署网站 $ hexo d deploy 清除缓存 $ hexo clean 发表草稿 $ hexo publish [layout] 渲染文件 $ hexo render [file2] … 获取版本 $ hexo version 二、了解GitGit的介绍在网上有一大堆，在这里我就不说了，同样记录一下常用命令 名字 命令 说明 初始化 git init 将当前目录初始化成为git仓库 查看状态 git status 获取一些状态信息，比如需要添加，提交的文件等 添加 git add 提交 git commit 查看log git log 可以查看所有产生的 commit 记录 获取分支 git branch *代表当前分支 新建分支 git branch a a表示你新建的分支名称 切换分支，tag git checkout a a表示你的分支名称，tag名称 新建并切换分支 git checkout -b a a同上 合并分支 git merge 需切换到主分支 删除分支 git branch -d a a同上 强制删除分支 git branch -D a a同上 获取tag git tag 新建tag git tag v1.0 v1.0表示tag名称 远程更新 git pull 远程添加 git push 设置别名 git config –global alias.s status 相当于设置快捷方式，status只是举例子，其他的都可以设置 三、搭建开始 注册Github账号，创建仓库。 安装node.js 安装git 安装配置Hexo 更换Hexo主题主题传送门 发表文章 END（就是这么简单！）","categories":[],"tags":[]}]}